import { IonicNativePlugin } from '@ionic-native/core';
import * as ɵngcc0 from '@angular/core';
export interface FileUploadOptions {
    /**
     * The name of the form element.
     * Defaults to 'file'.
     */
    fileKey?: string;
    /**
     * The file name to use when saving the file on the server.
     * Defaults to 'image.jpg'.
     */
    fileName?: string;
    /**
     * The HTTP method to use - either PUT or POST.
     * Defaults to POST.
     */
    httpMethod?: string;
    /**
     * The mime type of the data to upload.
     * Defaults to image/jpeg.
     */
    mimeType?: string;
    /**
     * A set of optional key/value pairs to pass in the HTTP request.
     */
    params?: {
        [s: string]: any;
    };
    /**
     * Whether to upload the data in chunked streaming mode.
     * Defaults to true.
     */
    chunkedMode?: boolean;
    /**
     * A map of header name/header values. Use an array to specify more
     * than one value. On iOS, FireOS, and Android, if a header named
     * Content-Type is present, multipart form data will NOT be used.
     */
    headers?: {
        [s: string]: any;
    };
}
export interface FileUploadResult {
    /**
     * The number of bytes sent to the server as part of the upload.
     */
    bytesSent: number;
    /**
     * The HTTP response code returned by the server.
     */
    responseCode: number;
    /**
     * The HTTP response returned by the server.
     */
    response: string;
    /**
     * The HTTP response headers by the server.
     */
    headers: {
        [s: string]: any;
    };
}
export interface FileTransferError {
    /**
     * One of the predefined error codes listed below.
     */
    code: number;
    /**
     * URL to the source.
     */
    source: string;
    /**
     * URL to the target.
     */
    target: string;
    /**
     * HTTP status code. This attribute is only available when a response
     * code is received from the HTTP connection.
     */
    http_status: number;
    /**
     * Response body. This attribute is only available when a response is received from the HTTP connection.
     */
    body: string;
    /**
     * Either e.getMessage or e.toString.
     */
    exception: string;
}
/**
 * @name File Transfer
 *
 * @description
 * This plugin allows you to upload and download files.
 *
 * @usage
 * ```typescript
 * import { FileTransfer, FileUploadOptions, FileTransferObject } from '@ionic-native/file-transfer/ngx';
 * import { File } from '@ionic-native/file';
 *
 * constructor(private transfer: FileTransfer, private file: File) { }
 *
 * ...
 *
 * const fileTransfer: FileTransferObject = this.transfer.create();
 *
 * // Upload a file:
 * fileTransfer.upload(..).then(..).catch(..);
 *
 * // Download a file:
 * fileTransfer.download(..).then(..).catch(..);
 *
 * // Abort active transfer:
 * fileTransfer.abort();
 *
 * // full example
 * upload() {
 *   let options: FileUploadOptions = {
 *      fileKey: 'file',
 *      fileName: 'name.jpg',
 *      headers: {}
 *      .....
 *   }
 *
 *   fileTransfer.upload('<file path>', '<api endpoint>', options)
 *    .then((data) => {
 *      // success
 *    }, (err) => {
 *      // error
 *    })
 * }
 *
 * download() {
 *   const url = 'http://www.example.com/file.pdf';
 *   fileTransfer.download(url, this.file.dataDirectory + 'file.pdf').then((entry) => {
 *     console.log('download complete: ' + entry.toURL());
 *   }, (error) => {
 *     // handle error
 *   });
 * }
 *
 * ```
 *
 * To store files in a different/publicly accessible directory, please refer to the following link
 * https://github.com/apache/cordova-plugin-file#where-to-store-files
 *
 * @interfaces
 * FileUploadOptions
 * FileUploadResult
 * FileTransferError
 * @classes
 * FileTransferObject
 */
export declare class FileTransfer extends IonicNativePlugin {
    /**
     * Error code rejected from upload with FileTransferError
     * Defined in FileTransferError.
     *      FILE_NOT_FOUND_ERR: 1   Return when file was not found
     *      INVALID_URL_ERR: 2,     Return when url was invalid
     *      CONNECTION_ERR: 3,      Return on connection error
     *      ABORT_ERR: 4,           Return on aborting
     *      NOT_MODIFIED_ERR: 5     Return on '304 Not Modified' HTTP response
     * @enum {number}
     */
    FileTransferErrorCode: {
        FILE_NOT_FOUND_ERR: number;
        INVALID_URL_ERR: number;
        CONNECTION_ERR: number;
        ABORT_ERR: number;
        NOT_MODIFIED_ERR: number;
    };
    /**
     * Creates a new FileTransfer object
     * @return {FileTransferObject}
     */
    create(): FileTransferObject;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<FileTransfer, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<FileTransfer>;
}
/**
 * @hidden
 */
export declare class FileTransferObject {
    private _objectInstance;
    constructor();
    /**
     * Sends a file to a server.
     *
     * @param {string} fileUrl  Filesystem URL representing the file on the device or a data URI. For backwards compatibility, this can also be the full path of the file on the device.
     * @param {string} url  URL of the server to receive the file, as encoded by encodeURI().
     * @param {FileUploadOptions} [options]  Optional parameters.
     * @param {boolean} [trustAllHosts]  Optional parameter, defaults to false. If set to true, it accepts all security certificates. This is useful since Android rejects self-signed security certificates. Not recommended for production use. Supported on Android and iOS.
     * @returns {Promise<FileUploadResult>} Returns a Promise that resolves to a FileUploadResult and rejects with FileTransferError.
     */
    upload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise<FileUploadResult>;
    /**
     * Downloads a file from server.
     *
     * @param {string} source  URL of the server to download the file, as encoded by encodeURI().
     * @param {string} target  Filesystem url representing the file on the device. For backwards compatibility, this can also be the full path of the file on the device.
     * @param {boolean} [trustAllHosts]  Optional parameter, defaults to false. If set to true, it accepts all security certificates. This is useful because Android rejects self-signed security certificates. Not recommended for production use. Supported on Android and iOS.
     * @param {object} [Optional] parameters, currently only supports headers (such as Authorization (Basic Authentication), etc).
     * @returns {Promise<any>} Returns a Promise that resolves to a FileEntry object.
     */
    download(source: string, target: string, trustAllHosts?: boolean, options?: {
        [s: string]: any;
    }): Promise<any>;
    /**
     * Registers a listener that gets called whenever a new chunk of data is transferred.
     * @param {Function} listener Listener that takes a progress event.
     */
    onProgress(listener: (event: ProgressEvent) => any): void;
    /**
     * Aborts an in-progress transfer. The onerror callback is passed a FileTransferError
     * object which has an error code of FileTransferError.ABORT_ERR.
     */
    abort(): void;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0tBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW9uaWNOYXRpdmVQbHVnaW4gfSBmcm9tICdAaW9uaWMtbmF0aXZlL2NvcmUnO1xuZXhwb3J0IGludGVyZmFjZSBGaWxlVXBsb2FkT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZvcm0gZWxlbWVudC5cbiAgICAgKiBEZWZhdWx0cyB0byAnZmlsZScuXG4gICAgICovXG4gICAgZmlsZUtleT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBuYW1lIHRvIHVzZSB3aGVuIHNhdmluZyB0aGUgZmlsZSBvbiB0aGUgc2VydmVyLlxuICAgICAqIERlZmF1bHRzIHRvICdpbWFnZS5qcGcnLlxuICAgICAqL1xuICAgIGZpbGVOYW1lPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgLSBlaXRoZXIgUFVUIG9yIFBPU1QuXG4gICAgICogRGVmYXVsdHMgdG8gUE9TVC5cbiAgICAgKi9cbiAgICBodHRwTWV0aG9kPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW1lIHR5cGUgb2YgdGhlIGRhdGEgdG8gdXBsb2FkLlxuICAgICAqIERlZmF1bHRzIHRvIGltYWdlL2pwZWcuXG4gICAgICovXG4gICAgbWltZVR5cGU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQSBzZXQgb2Ygb3B0aW9uYWwga2V5L3ZhbHVlIHBhaXJzIHRvIHBhc3MgaW4gdGhlIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBwYXJhbXM/OiB7XG4gICAgICAgIFtzOiBzdHJpbmddOiBhbnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHVwbG9hZCB0aGUgZGF0YSBpbiBjaHVua2VkIHN0cmVhbWluZyBtb2RlLlxuICAgICAqIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICovXG4gICAgY2h1bmtlZE1vZGU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGhlYWRlciBuYW1lL2hlYWRlciB2YWx1ZXMuIFVzZSBhbiBhcnJheSB0byBzcGVjaWZ5IG1vcmVcbiAgICAgKiB0aGFuIG9uZSB2YWx1ZS4gT24gaU9TLCBGaXJlT1MsIGFuZCBBbmRyb2lkLCBpZiBhIGhlYWRlciBuYW1lZFxuICAgICAqIENvbnRlbnQtVHlwZSBpcyBwcmVzZW50LCBtdWx0aXBhcnQgZm9ybSBkYXRhIHdpbGwgTk9UIGJlIHVzZWQuXG4gICAgICovXG4gICAgaGVhZGVycz86IHtcbiAgICAgICAgW3M6IHN0cmluZ106IGFueTtcbiAgICB9O1xufVxuZXhwb3J0IGludGVyZmFjZSBGaWxlVXBsb2FkUmVzdWx0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHNlbnQgdG8gdGhlIHNlcnZlciBhcyBwYXJ0IG9mIHRoZSB1cGxvYWQuXG4gICAgICovXG4gICAgYnl0ZXNTZW50OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIEhUVFAgcmVzcG9uc2UgY29kZSByZXR1cm5lZCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIHJlc3BvbnNlQ29kZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBIVFRQIHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgcmVzcG9uc2U6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCByZXNwb25zZSBoZWFkZXJzIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgaGVhZGVyczoge1xuICAgICAgICBbczogc3RyaW5nXTogYW55O1xuICAgIH07XG59XG5leHBvcnQgaW50ZXJmYWNlIEZpbGVUcmFuc2ZlckVycm9yIHtcbiAgICAvKipcbiAgICAgKiBPbmUgb2YgdGhlIHByZWRlZmluZWQgZXJyb3IgY29kZXMgbGlzdGVkIGJlbG93LlxuICAgICAqL1xuICAgIGNvZGU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBVUkwgdG8gdGhlIHNvdXJjZS5cbiAgICAgKi9cbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBVUkwgdG8gdGhlIHRhcmdldC5cbiAgICAgKi9cbiAgICB0YXJnZXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBIVFRQIHN0YXR1cyBjb2RlLiBUaGlzIGF0dHJpYnV0ZSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIGEgcmVzcG9uc2VcbiAgICAgKiBjb2RlIGlzIHJlY2VpdmVkIGZyb20gdGhlIEhUVFAgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBodHRwX3N0YXR1czogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJlc3BvbnNlIGJvZHkuIFRoaXMgYXR0cmlidXRlIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gYSByZXNwb25zZSBpcyByZWNlaXZlZCBmcm9tIHRoZSBIVFRQIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYm9keTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEVpdGhlciBlLmdldE1lc3NhZ2Ugb3IgZS50b1N0cmluZy5cbiAgICAgKi9cbiAgICBleGNlcHRpb246IHN0cmluZztcbn1cbi8qKlxuICogQG5hbWUgRmlsZSBUcmFuc2ZlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBwbHVnaW4gYWxsb3dzIHlvdSB0byB1cGxvYWQgYW5kIGRvd25sb2FkIGZpbGVzLlxuICpcbiAqIEB1c2FnZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgRmlsZVRyYW5zZmVyLCBGaWxlVXBsb2FkT3B0aW9ucywgRmlsZVRyYW5zZmVyT2JqZWN0IH0gZnJvbSAnQGlvbmljLW5hdGl2ZS9maWxlLXRyYW5zZmVyL25neCc7XG4gKiBpbXBvcnQgeyBGaWxlIH0gZnJvbSAnQGlvbmljLW5hdGl2ZS9maWxlJztcbiAqXG4gKiBjb25zdHJ1Y3Rvcihwcml2YXRlIHRyYW5zZmVyOiBGaWxlVHJhbnNmZXIsIHByaXZhdGUgZmlsZTogRmlsZSkgeyB9XG4gKlxuICogLi4uXG4gKlxuICogY29uc3QgZmlsZVRyYW5zZmVyOiBGaWxlVHJhbnNmZXJPYmplY3QgPSB0aGlzLnRyYW5zZmVyLmNyZWF0ZSgpO1xuICpcbiAqIC8vIFVwbG9hZCBhIGZpbGU6XG4gKiBmaWxlVHJhbnNmZXIudXBsb2FkKC4uKS50aGVuKC4uKS5jYXRjaCguLik7XG4gKlxuICogLy8gRG93bmxvYWQgYSBmaWxlOlxuICogZmlsZVRyYW5zZmVyLmRvd25sb2FkKC4uKS50aGVuKC4uKS5jYXRjaCguLik7XG4gKlxuICogLy8gQWJvcnQgYWN0aXZlIHRyYW5zZmVyOlxuICogZmlsZVRyYW5zZmVyLmFib3J0KCk7XG4gKlxuICogLy8gZnVsbCBleGFtcGxlXG4gKiB1cGxvYWQoKSB7XG4gKiAgIGxldCBvcHRpb25zOiBGaWxlVXBsb2FkT3B0aW9ucyA9IHtcbiAqICAgICAgZmlsZUtleTogJ2ZpbGUnLFxuICogICAgICBmaWxlTmFtZTogJ25hbWUuanBnJyxcbiAqICAgICAgaGVhZGVyczoge31cbiAqICAgICAgLi4uLi5cbiAqICAgfVxuICpcbiAqICAgZmlsZVRyYW5zZmVyLnVwbG9hZCgnPGZpbGUgcGF0aD4nLCAnPGFwaSBlbmRwb2ludD4nLCBvcHRpb25zKVxuICogICAgLnRoZW4oKGRhdGEpID0+IHtcbiAqICAgICAgLy8gc3VjY2Vzc1xuICogICAgfSwgKGVycikgPT4ge1xuICogICAgICAvLyBlcnJvclxuICogICAgfSlcbiAqIH1cbiAqXG4gKiBkb3dubG9hZCgpIHtcbiAqICAgY29uc3QgdXJsID0gJ2h0dHA6Ly93d3cuZXhhbXBsZS5jb20vZmlsZS5wZGYnO1xuICogICBmaWxlVHJhbnNmZXIuZG93bmxvYWQodXJsLCB0aGlzLmZpbGUuZGF0YURpcmVjdG9yeSArICdmaWxlLnBkZicpLnRoZW4oKGVudHJ5KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ2Rvd25sb2FkIGNvbXBsZXRlOiAnICsgZW50cnkudG9VUkwoKSk7XG4gKiAgIH0sIChlcnJvcikgPT4ge1xuICogICAgIC8vIGhhbmRsZSBlcnJvclxuICogICB9KTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBUbyBzdG9yZSBmaWxlcyBpbiBhIGRpZmZlcmVudC9wdWJsaWNseSBhY2Nlc3NpYmxlIGRpcmVjdG9yeSwgcGxlYXNlIHJlZmVyIHRvIHRoZSBmb2xsb3dpbmcgbGlua1xuICogaHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9jb3Jkb3ZhLXBsdWdpbi1maWxlI3doZXJlLXRvLXN0b3JlLWZpbGVzXG4gKlxuICogQGludGVyZmFjZXNcbiAqIEZpbGVVcGxvYWRPcHRpb25zXG4gKiBGaWxlVXBsb2FkUmVzdWx0XG4gKiBGaWxlVHJhbnNmZXJFcnJvclxuICogQGNsYXNzZXNcbiAqIEZpbGVUcmFuc2Zlck9iamVjdFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBGaWxlVHJhbnNmZXIgZXh0ZW5kcyBJb25pY05hdGl2ZVBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSByZWplY3RlZCBmcm9tIHVwbG9hZCB3aXRoIEZpbGVUcmFuc2ZlckVycm9yXG4gICAgICogRGVmaW5lZCBpbiBGaWxlVHJhbnNmZXJFcnJvci5cbiAgICAgKiAgICAgIEZJTEVfTk9UX0ZPVU5EX0VSUjogMSAgIFJldHVybiB3aGVuIGZpbGUgd2FzIG5vdCBmb3VuZFxuICAgICAqICAgICAgSU5WQUxJRF9VUkxfRVJSOiAyLCAgICAgUmV0dXJuIHdoZW4gdXJsIHdhcyBpbnZhbGlkXG4gICAgICogICAgICBDT05ORUNUSU9OX0VSUjogMywgICAgICBSZXR1cm4gb24gY29ubmVjdGlvbiBlcnJvclxuICAgICAqICAgICAgQUJPUlRfRVJSOiA0LCAgICAgICAgICAgUmV0dXJuIG9uIGFib3J0aW5nXG4gICAgICogICAgICBOT1RfTU9ESUZJRURfRVJSOiA1ICAgICBSZXR1cm4gb24gJzMwNCBOb3QgTW9kaWZpZWQnIEhUVFAgcmVzcG9uc2VcbiAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAqL1xuICAgIEZpbGVUcmFuc2ZlckVycm9yQ29kZToge1xuICAgICAgICBGSUxFX05PVF9GT1VORF9FUlI6IG51bWJlcjtcbiAgICAgICAgSU5WQUxJRF9VUkxfRVJSOiBudW1iZXI7XG4gICAgICAgIENPTk5FQ1RJT05fRVJSOiBudW1iZXI7XG4gICAgICAgIEFCT1JUX0VSUjogbnVtYmVyO1xuICAgICAgICBOT1RfTU9ESUZJRURfRVJSOiBudW1iZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZpbGVUcmFuc2ZlciBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtGaWxlVHJhbnNmZXJPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlKCk6IEZpbGVUcmFuc2Zlck9iamVjdDtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBGaWxlVHJhbnNmZXJPYmplY3Qge1xuICAgIHByaXZhdGUgX29iamVjdEluc3RhbmNlO1xuICAgIGNvbnN0cnVjdG9yKCk7XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBmaWxlIHRvIGEgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVVcmwgIEZpbGVzeXN0ZW0gVVJMIHJlcHJlc2VudGluZyB0aGUgZmlsZSBvbiB0aGUgZGV2aWNlIG9yIGEgZGF0YSBVUkkuIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgdGhpcyBjYW4gYWxzbyBiZSB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlIG9uIHRoZSBkZXZpY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgVVJMIG9mIHRoZSBzZXJ2ZXIgdG8gcmVjZWl2ZSB0aGUgZmlsZSwgYXMgZW5jb2RlZCBieSBlbmNvZGVVUkkoKS5cbiAgICAgKiBAcGFyYW0ge0ZpbGVVcGxvYWRPcHRpb25zfSBbb3B0aW9uc10gIE9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdHJ1c3RBbGxIb3N0c10gIE9wdGlvbmFsIHBhcmFtZXRlciwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIHNldCB0byB0cnVlLCBpdCBhY2NlcHRzIGFsbCBzZWN1cml0eSBjZXJ0aWZpY2F0ZXMuIFRoaXMgaXMgdXNlZnVsIHNpbmNlIEFuZHJvaWQgcmVqZWN0cyBzZWxmLXNpZ25lZCBzZWN1cml0eSBjZXJ0aWZpY2F0ZXMuIE5vdCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiB1c2UuIFN1cHBvcnRlZCBvbiBBbmRyb2lkIGFuZCBpT1MuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmlsZVVwbG9hZFJlc3VsdD59IFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGaWxlVXBsb2FkUmVzdWx0IGFuZCByZWplY3RzIHdpdGggRmlsZVRyYW5zZmVyRXJyb3IuXG4gICAgICovXG4gICAgdXBsb2FkKGZpbGVVcmw6IHN0cmluZywgdXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBGaWxlVXBsb2FkT3B0aW9ucywgdHJ1c3RBbGxIb3N0cz86IGJvb2xlYW4pOiBQcm9taXNlPEZpbGVVcGxvYWRSZXN1bHQ+O1xuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlICBVUkwgb2YgdGhlIHNlcnZlciB0byBkb3dubG9hZCB0aGUgZmlsZSwgYXMgZW5jb2RlZCBieSBlbmNvZGVVUkkoKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0ICBGaWxlc3lzdGVtIHVybCByZXByZXNlbnRpbmcgdGhlIGZpbGUgb24gdGhlIGRldmljZS4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIGNhbiBhbHNvIGJlIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUgb24gdGhlIGRldmljZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cnVzdEFsbEhvc3RzXSAgT3B0aW9uYWwgcGFyYW1ldGVyLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgc2V0IHRvIHRydWUsIGl0IGFjY2VwdHMgYWxsIHNlY3VyaXR5IGNlcnRpZmljYXRlcy4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBBbmRyb2lkIHJlamVjdHMgc2VsZi1zaWduZWQgc2VjdXJpdHkgY2VydGlmaWNhdGVzLiBOb3QgcmVjb21tZW5kZWQgZm9yIHByb2R1Y3Rpb24gdXNlLiBTdXBwb3J0ZWQgb24gQW5kcm9pZCBhbmQgaU9TLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbT3B0aW9uYWxdIHBhcmFtZXRlcnMsIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGhlYWRlcnMgKHN1Y2ggYXMgQXV0aG9yaXphdGlvbiAoQmFzaWMgQXV0aGVudGljYXRpb24pLCBldGMpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGaWxlRW50cnkgb2JqZWN0LlxuICAgICAqL1xuICAgIGRvd25sb2FkKHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZywgdHJ1c3RBbGxIb3N0cz86IGJvb2xlYW4sIG9wdGlvbnM/OiB7XG4gICAgICAgIFtzOiBzdHJpbmddOiBhbnk7XG4gICAgfSk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IGNodW5rIG9mIGRhdGEgaXMgdHJhbnNmZXJyZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIgdGhhdCB0YWtlcyBhIHByb2dyZXNzIGV2ZW50LlxuICAgICAqL1xuICAgIG9uUHJvZ3Jlc3MobGlzdGVuZXI6IChldmVudDogUHJvZ3Jlc3NFdmVudCkgPT4gYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBYm9ydHMgYW4gaW4tcHJvZ3Jlc3MgdHJhbnNmZXIuIFRoZSBvbmVycm9yIGNhbGxiYWNrIGlzIHBhc3NlZCBhIEZpbGVUcmFuc2ZlckVycm9yXG4gICAgICogb2JqZWN0IHdoaWNoIGhhcyBhbiBlcnJvciBjb2RlIG9mIEZpbGVUcmFuc2ZlckVycm9yLkFCT1JUX0VSUi5cbiAgICAgKi9cbiAgICBhYm9ydCgpOiB2b2lkO1xufVxuIl19