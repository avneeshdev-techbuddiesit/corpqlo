import { IonicNativePlugin } from '@ionic-native/core';
/**
 * @name Native Geocoder
 * @description
 * Cordova plugin for native forward and reverse geocoding
 *
 * @usage
 * ```typescript
 * import { NativeGeocoder, NativeGeocoderResult, NativeGeocoderOptions } from '@ionic-native/native-geocoder/ngx';
 *
 * constructor(private nativeGeocoder: NativeGeocoder) { }
 *
 * ...
 *
 * let options: NativeGeocoderOptions = {
 *     useLocale: true,
 *     maxResults: 5
 * };
 *
 * this.nativeGeocoder.reverseGeocode(52.5072095, 13.1452818, options)
 *   .then((result: NativeGeocoderResult[]) => console.log(JSON.stringify(result[0])))
 *   .catch((error: any) => console.log(error));
 *
 * this.nativeGeocoder.forwardGeocode('Berlin', options)
 *   .then((result: NativeGeocoderResult[]) => console.log('The coordinates are latitude=' + result[0].latitude + ' and longitude=' + result[0].longitude))
 *   .catch((error: any) => console.log(error));
 * ```
 * @interfaces
 * NativeGeocoderResult
 * NativeGeocoderOptions
 */
import * as ɵngcc0 from '@angular/core';
export declare class NativeGeocoder extends IonicNativePlugin {
    /**
     * Reverse geocode a given latitude and longitude to find location address
     * @param latitude {number} The latitude
     * @param longitude {number} The longitude
     * @param options {NativeGeocoderOptions} The options
     * @return {Promise<NativeGeocoderResult[]>}
     */
    reverseGeocode(latitude: number, longitude: number, options?: NativeGeocoderOptions): Promise<NativeGeocoderResult[]>;
    /**
     * Forward geocode a given address to find coordinates
     * @param addressString {string} The address to be geocoded
     * @param options {NativeGeocoderOptions} The options
     * @return {Promise<NativeGeocoderResult[]>}
     */
    forwardGeocode(addressString: string, options?: NativeGeocoderOptions): Promise<NativeGeocoderResult[]>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NativeGeocoder, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NativeGeocoder>;
}
/**
 * Encapsulates format information about a geocoding result.
 * more Info:
 *  - https://developer.apple.com/documentation/corelocation/clplacemark
 *  - https://developer.android.com/reference/android/location/Address.html
 */
export interface NativeGeocoderResult {
    /**
     * The latitude.
     */
    latitude: string;
    /**
     * The longitude.
     */
    longitude: string;
    /**
     * The country code.
     */
    countryCode: string;
    /**
     * The country name.
     */
    countryName: string;
    /**
     * The postal code.
     */
    postalCode: string;
    /**
     * The administrativeArea.
     */
    administrativeArea: string;
    /**
     * The subAdministrativeArea.
     */
    subAdministrativeArea: string;
    /**
     * The locality.
     */
    locality: string;
    /**
     * The subLocality.
     */
    subLocality: string;
    /**
     * The thoroughfare.
     */
    thoroughfare: string;
    /**
     * The subThoroughfare.
     */
    subThoroughfare: string;
    /**
     * The areasOfInterest
     */
    areasOfInterest: string[];
}
/**
 * Options for reverse and forward geocoding.
 */
export interface NativeGeocoderOptions {
    /**
     * The locale to use when returning the address information.
     * If set to 'false' the locale will always be 'en_US'.
     * Default is 'true'
     */
    useLocale: boolean;
    /**
     * The default locale to use when returning the address information.
     * e.g.: 'fa-IR' or 'de_DE'.
     */
    defaultLocale?: string;
    /**
     * The maximum number of result to return (max is 5).
     * Default is 1
     */
    maxResults: number;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElvbmljTmF0aXZlUGx1Z2luIH0gZnJvbSAnQGlvbmljLW5hdGl2ZS9jb3JlJztcbi8qKlxuICogQG5hbWUgTmF0aXZlIEdlb2NvZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvcmRvdmEgcGx1Z2luIGZvciBuYXRpdmUgZm9yd2FyZCBhbmQgcmV2ZXJzZSBnZW9jb2RpbmdcbiAqXG4gKiBAdXNhZ2VcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IE5hdGl2ZUdlb2NvZGVyLCBOYXRpdmVHZW9jb2RlclJlc3VsdCwgTmF0aXZlR2VvY29kZXJPcHRpb25zIH0gZnJvbSAnQGlvbmljLW5hdGl2ZS9uYXRpdmUtZ2VvY29kZXIvbmd4JztcbiAqXG4gKiBjb25zdHJ1Y3Rvcihwcml2YXRlIG5hdGl2ZUdlb2NvZGVyOiBOYXRpdmVHZW9jb2RlcikgeyB9XG4gKlxuICogLi4uXG4gKlxuICogbGV0IG9wdGlvbnM6IE5hdGl2ZUdlb2NvZGVyT3B0aW9ucyA9IHtcbiAqICAgICB1c2VMb2NhbGU6IHRydWUsXG4gKiAgICAgbWF4UmVzdWx0czogNVxuICogfTtcbiAqXG4gKiB0aGlzLm5hdGl2ZUdlb2NvZGVyLnJldmVyc2VHZW9jb2RlKDUyLjUwNzIwOTUsIDEzLjE0NTI4MTgsIG9wdGlvbnMpXG4gKiAgIC50aGVuKChyZXN1bHQ6IE5hdGl2ZUdlb2NvZGVyUmVzdWx0W10pID0+IGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHJlc3VsdFswXSkpKVxuICogICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IGNvbnNvbGUubG9nKGVycm9yKSk7XG4gKlxuICogdGhpcy5uYXRpdmVHZW9jb2Rlci5mb3J3YXJkR2VvY29kZSgnQmVybGluJywgb3B0aW9ucylcbiAqICAgLnRoZW4oKHJlc3VsdDogTmF0aXZlR2VvY29kZXJSZXN1bHRbXSkgPT4gY29uc29sZS5sb2coJ1RoZSBjb29yZGluYXRlcyBhcmUgbGF0aXR1ZGU9JyArIHJlc3VsdFswXS5sYXRpdHVkZSArICcgYW5kIGxvbmdpdHVkZT0nICsgcmVzdWx0WzBdLmxvbmdpdHVkZSkpXG4gKiAgIC5jYXRjaCgoZXJyb3I6IGFueSkgPT4gY29uc29sZS5sb2coZXJyb3IpKTtcbiAqIGBgYFxuICogQGludGVyZmFjZXNcbiAqIE5hdGl2ZUdlb2NvZGVyUmVzdWx0XG4gKiBOYXRpdmVHZW9jb2Rlck9wdGlvbnNcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmF0aXZlR2VvY29kZXIgZXh0ZW5kcyBJb25pY05hdGl2ZVBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogUmV2ZXJzZSBnZW9jb2RlIGEgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSB0byBmaW5kIGxvY2F0aW9uIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gbGF0aXR1ZGUge251bWJlcn0gVGhlIGxhdGl0dWRlXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSB7bnVtYmVyfSBUaGUgbG9uZ2l0dWRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMge05hdGl2ZUdlb2NvZGVyT3B0aW9uc30gVGhlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPE5hdGl2ZUdlb2NvZGVyUmVzdWx0W10+fVxuICAgICAqL1xuICAgIHJldmVyc2VHZW9jb2RlKGxhdGl0dWRlOiBudW1iZXIsIGxvbmdpdHVkZTogbnVtYmVyLCBvcHRpb25zPzogTmF0aXZlR2VvY29kZXJPcHRpb25zKTogUHJvbWlzZTxOYXRpdmVHZW9jb2RlclJlc3VsdFtdPjtcbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIGdlb2NvZGUgYSBnaXZlbiBhZGRyZXNzIHRvIGZpbmQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gYWRkcmVzc1N0cmluZyB7c3RyaW5nfSBUaGUgYWRkcmVzcyB0byBiZSBnZW9jb2RlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtOYXRpdmVHZW9jb2Rlck9wdGlvbnN9IFRoZSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxOYXRpdmVHZW9jb2RlclJlc3VsdFtdPn1cbiAgICAgKi9cbiAgICBmb3J3YXJkR2VvY29kZShhZGRyZXNzU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBOYXRpdmVHZW9jb2Rlck9wdGlvbnMpOiBQcm9taXNlPE5hdGl2ZUdlb2NvZGVyUmVzdWx0W10+O1xufVxuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgZm9ybWF0IGluZm9ybWF0aW9uIGFib3V0IGEgZ2VvY29kaW5nIHJlc3VsdC5cbiAqIG1vcmUgSW5mbzpcbiAqICAtIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9kb2N1bWVudGF0aW9uL2NvcmVsb2NhdGlvbi9jbHBsYWNlbWFya1xuICogIC0gaHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbG9jYXRpb24vQWRkcmVzcy5odG1sXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF0aXZlR2VvY29kZXJSZXN1bHQge1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXRpdHVkZS5cbiAgICAgKi9cbiAgICBsYXRpdHVkZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb25naXR1ZGUuXG4gICAgICovXG4gICAgbG9uZ2l0dWRlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGNvdW50cnkgY29kZS5cbiAgICAgKi9cbiAgICBjb3VudHJ5Q29kZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb3VudHJ5IG5hbWUuXG4gICAgICovXG4gICAgY291bnRyeU5hbWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zdGFsIGNvZGUuXG4gICAgICovXG4gICAgcG9zdGFsQ29kZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBhZG1pbmlzdHJhdGl2ZUFyZWEuXG4gICAgICovXG4gICAgYWRtaW5pc3RyYXRpdmVBcmVhOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIHN1YkFkbWluaXN0cmF0aXZlQXJlYS5cbiAgICAgKi9cbiAgICBzdWJBZG1pbmlzdHJhdGl2ZUFyZWE6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWxpdHkuXG4gICAgICovXG4gICAgbG9jYWxpdHk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgc3ViTG9jYWxpdHkuXG4gICAgICovXG4gICAgc3ViTG9jYWxpdHk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgdGhvcm91Z2hmYXJlLlxuICAgICAqL1xuICAgIHRob3JvdWdoZmFyZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJUaG9yb3VnaGZhcmUuXG4gICAgICovXG4gICAgc3ViVGhvcm91Z2hmYXJlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZWFzT2ZJbnRlcmVzdFxuICAgICAqL1xuICAgIGFyZWFzT2ZJbnRlcmVzdDogc3RyaW5nW107XG59XG4vKipcbiAqIE9wdGlvbnMgZm9yIHJldmVyc2UgYW5kIGZvcndhcmQgZ2VvY29kaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hdGl2ZUdlb2NvZGVyT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsZSB0byB1c2Ugd2hlbiByZXR1cm5pbmcgdGhlIGFkZHJlc3MgaW5mb3JtYXRpb24uXG4gICAgICogSWYgc2V0IHRvICdmYWxzZScgdGhlIGxvY2FsZSB3aWxsIGFsd2F5cyBiZSAnZW5fVVMnLlxuICAgICAqIERlZmF1bHQgaXMgJ3RydWUnXG4gICAgICovXG4gICAgdXNlTG9jYWxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGxvY2FsZSB0byB1c2Ugd2hlbiByZXR1cm5pbmcgdGhlIGFkZHJlc3MgaW5mb3JtYXRpb24uXG4gICAgICogZS5nLjogJ2ZhLUlSJyBvciAnZGVfREUnLlxuICAgICAqL1xuICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdCB0byByZXR1cm4gKG1heCBpcyA1KS5cbiAgICAgKiBEZWZhdWx0IGlzIDFcbiAgICAgKi9cbiAgICBtYXhSZXN1bHRzOiBudW1iZXI7XG59XG4iXX0=